# Object와 의존관계-1

## DAO

### DAO  정의

- DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

### Java Bean

- 간단히 빈이라고 하며, 두 가지 관례를 따라 만들어진 오브젝트이다.
  - 디폴트 생성자 : 디폴트 생성자는 인자는 하나도 없고, 내용도 텅 비어있는 생성자이다.(디폴트 생성자가 없으면, new 연산자로 해당 객체를 못불러온다.) 
    자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 통해 오브젝트를 생성하기 때문이다.
  - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성. setter, getter로 시작하는 접근자 메소드를 이용해 수정 또는 조회할 수 있다. (VO의 속성들)
  - VO(Value Object) / DTO : 계층형 구조에서 계층간 값을 전달하기 위해 자바 빈의 형태로 구현한 클래스

## DAO의 분리 (상속)

- 클라이언트가 기능 변경을 요청했을 때, 분리와 확장을 고려한 설계를 했다면 필요한 작업을 최소화할 수 있다.

### 관심사의 분리

- 관심이 같은 것끼리는 하나의 객체로 모이게 해, 서로 영향을 주지 않도록 분리하는 것.(객체 지향)
- 하지만 언젠가 뭉쳐 있는 여러 관심사를 적절하게 구분하고 따로 분리하는 작업을 해야 함.
- 관심사에 따라 효과적으로 집중할 수 있게 만들어 줘야 함.(AOP / 관점 중심 프로그래밍)

### DAO의 관심사 분리

- DB 연결을 위한 커넥션 : DB 종류, 드라이버 종류, 로그인 정보 등
- DB에 보낼 SQL 문장 및 statement 바인딩, 실행 등
- statement, connection 닫아서 리소스를 시스템에 돌려주기
- 예외사항 처리
- 중복된 코드를 독립적인 메소드로 만들어 중복을 제거 (scope 생각해서 작성할 것)

#### EX) DB연결 방법만 두 회사 버전으로 나눠서 따로 써야 할 경우

- 관점에 따라 DAO를 분리해 상속한다.
- 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당하는 UserDAO
  - SQL 작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달
- DB연결 방법에 대한 관심을 담당하는 DUserDAO(회사1), NUserDAO(회사2)
- UserDAO <- DUserDAO, NUserDAO (상속)
- 그 결과, UserDAO 코드 수정 없이 DB연결 기능을 새롭게 정의한 클래스를 만들수 있다. => 손쉽게 확장

### 리펙토링과 테스트

- main을 이용해 테스트를 할 경우, 테이블의 id 중복 때문에 예외가 발생할 수 있다. : 사용자 정보 삭제

#### 리펙토링 

- 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업
- 내부 설계가 개선되어 코드를 이해하기 더 편해지고 변화에 효율적으로 대처 가능
- 유지보수 용이, 견고하면서도 유연한 제품 개발 가능
- 메소드 추출 기법(중복 코드를 묶어 새로운 메소드 생성)
- [리펙토링 / 저자: 마틴 파울러, 켄트 벡 공저] 책 추천

 ### 디자인 패턴

#### 정의

- 소프트웨어 설계시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션.

#### 특징

- 모든 패턴은 간결한 이름이 있어서, 패턴 이름을 언급하는 것만으로 설계의 의도와 해결책을 함께 설명할 수 있다는 장점이 있다.
- 디자인 패턴은 주로 객체 지향 설계 원칙을 이용해 문제를 해결한다.
- 패턴의 설계 구조 및 결과로 나온 코드는 대부분 비슷한데, 이는 객체 지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지 구조로 정리되기 때문이다. 두 가지는 **클래스 상속**과 **오브젝트 합성**이다.
- 패턴에서 가장 중요한 것은 핵심이 담긴 목적 또는 의도다. (관점)
- 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지를 기억해둬야 한다.
- 참고문헌 : GoF의 디자인 패턴(에릭 감마 외)

### 템플릿 메소드 패턴

#### 정의

- 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법.
- 템플릿 메소드 : 기본 알고리즘 골격을 담은 메소드

#### 특징

- 변하지 않는 기능은 슈퍼 클래스에 만들어 두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.

- 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 메소드를 만든다.

- 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 한다.

  - 훅 메소드의 경우

- 서브 클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다.

- ```java
  protected void Paging() {}; // 훅 메서드 : 선택적 오버라이딩이 가능
  protected abstract void Paging(); // 추상 메서드 : 선택적 오버라이딩 불가
  ```
  
- [참고 페이지](https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html)



### 팩토리 메소드 패턴

#### 정의

- 템플릿 메소드 패턴과 마찬가지로, 상속을 통해 기능을 확장하게 하는 패턴. 구조도 비슷하다.
- 팩토리 메소드 : 서브 클래스에서 오브젝트 생성 방법과 클래스를 결성할 수 있도록 미리 정의해둔 메소드.
- 팩토리 메소드 패턴 : 팩토리 메소드 방식을 통해 오브젝트 생성 방법을 슈퍼클래스의 기본 코드에서 독립시키는 방법.

#### 특징

- 주로 인터페이스 타입으로 오브젝트를 리턴하므로, 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서 모른다.
- 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다.(overriding)
- 자바에서는 종종 오브젝트를 생성하는 기능을 가진 메소드를 팩토리 메소드라고 부르기도 하지만, 팩토리 메소드의 패턴과 다른 의미이다.

### 템플릿 메소드 패턴 vs 팩토리 메소드 패턴 (생각)

- 고정되고 공통적인 메소드가 존재하면 템플릿 메소드 패턴을 사용. 존재하지 않으면 팩토리 메소드 패턴을 사용.
- 그 결과, 템플릿 메소드 패턴은 Abstract, 팩토리 메소드 패턴은 Interface를 사용하는 듯.

### 두가지 메소드 패턴의 단점

- 상속을 했기 때문에, 이미 상속을 사용하면 사용을 못한다.(다중상속 불가)
- 또한, 상속을 통한 상하위 클래스의 관계는 생각보다 관계가 밀접하기 때문에 관심사가 같은 점이 있다.
- 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있기 때문에, 슈퍼클래스 내부의 변경이 있을 때 모든 서브 클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.
  - 이럴 경우, 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야 할지도 모른다.
- DAO의 경우, 확장된 기능인 DB커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 단점이다.



## DAO의 확장

### 독립된 클래스로 분리

- 상속이 아닌 별도의 클래스를 만들어 분리할 경우 관심사는 분명히 떨어졌지만, 코드의 재사용성 및 효율성에 문제가 생긴다.
- 이런 문제는 import한 클래스의 메소드를 일일이 알고 있어야 하기 때문이다.

### 인터페이스 도입

- 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 느슨한 연결고리인 인터페이스를 도입하는 것이다.

- 인터페이스는 자바가 추상화를 위해 제공하는 가장 유용한 도구이다.

- 인터페이스를 사용할 경우, 클래스에 대한 구체적인 정보는 제거가 가능했지만, 초기에 한 번 어떤 클래스의 오브젝트를 사용할지 결정하는 생성자의 코드는 제거되지 않고 남아 있다.

- EX)

  ```java
  public interface ConnectionMaker{
      public Connection makeConnection();
  }
  
  public class DconnectionMaker implements ConnectionMaker{
      ...
  } 
  
  public class UserDao{
      private ConnectionMaker connectionMaker;
      public UserDao(){
          connectionMaker = new DconnectionMaker();
          // 이때 어떤 클래스를 사용할지 결정해야하는 생성자의 코드가 존재한다.
      }
  }
  ```

- 저 코드가 존재하면 다른 회사의 connection을 사용한다고 가정할 때, 여전히 UserDao의 생성자 메소드를 직접 수정해야 한다.

### 관계설정 책임의 분리

#### 인터페이스를 이용해도 관심사가 분리되지 않는 이유

- 위의 예제처럼, UserDao에 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지 결정하는 코드가 있다.
- 정리하면, UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 코드이다.
- 이 관심사를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 독립적으로 확장 가능한 클래스가 될 수 없다.

- 이 문제를 해결하는 방법은 바로 UserDao의 클라이언트 오브젝트에 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리하는 것이다.
  - 클라이언트 오브젝트 : 특정 오브젝트의 기능을 import해 가져온 오브젝트. 그 특정 오브젝트는 서비스라고 한다.
  - UserDao의 클라이언트 오브젝트(생각) : Service 계층의 오브젝트 

#### 클라이언트 오브젝트로 관심사 분리하기

- UserDao의 클라이언트 오브젝트에 ConnectionMaker 심기

  - 클래스 사이의 관계를 설정해주는 것이 아니다.

  - 클래스 사이 관계를 설정한다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다.

  - 따라서 클래스가 아닌, 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다는 것이다.

  - ```java
    connectionMaker = new DConnectionMaker();
    ```

  - UserDao의 모든 코드는 ConnectionMaker 인터페이스 외에는 어떤 클래스와도 관계가 있어선 안된다. (대신 특정 클래스의 오브젝트와 관계를 맺어야 한다.)

    - ''클래스의 오브젝트와 관계를 맺다.''는 클래스 사이 관계를 맺는 다는 것이 아니라, 오브젝트 사이에 동적 관계가 만들어지는 것이다.(reflection)

  - 의존관계를 맺어주면 런타임 시점에 오브젝트간 관계가 동적으로 형성된다. 그리고 이는 클라이언트 오브젝트의 역할이다.

- ```java
  //UserDao 생성자 수정
  @Repository
  public class UserDao {
  	private ConnectionMaker connectionmaker;
	public UserDao(ConnectionMaker connectionMaker) {
  		this.connectionmaker = connectionMaker;
  	}
  }
  	
  //Service 수정
  @Service
  public class UserService {	
  	public static void main(String[] args) throws ClassNotFoundException, SQLException {
  		ConnectionMaker connectionMaker = new DConnectionMaker();
  		UserDao dao = new UserDao(connectionMaker);
      }
  }
  ```
  
- 이럴경우 관심사가 다른 것을 분리할 수 있다.

- 더 이상 DB 생성 방법이나 전략에 따라 UserDao 코드는 안바꿔도 된다.

- ConnectionMaker라는 인터페이스를 사용하기만 한다면 다른 DAO 클래스에서도 ConnectionMaker의 구현 클래스를 적용할 수 있다.

- DAO가 많아져도 DB 접속 방법에 대한 관심은 오직 한 곳에 집중시킬 수 있고, 접속 방법이 바뀌어도 한 곳의 코드만 수정하면 된다.

## 원칙과 패턴

- 지금까지 코드를 개선한 결과를 객체지향 기술의 여러가지 이론을 통해 설명하는 파트.

### 개방 폐쇄 원칙(OCP, Open-Closed Principle)



## 요약

- 관심사에 따라 분리와 확장을 고려한 설계를 했다면 필요한 작업을 최소화할 수 있다.
- 디자인 패턴 : 패턴들 대부분 객체 지향이라 비슷하다. 관점에 따라 설계가 나뉜다.
- 탬플릿 메소드 패턴 : 훅 메서드, 추상 메서드, 슈퍼클래스에서 공통되고 주요한 로직 생성 
- 팩토리 메소드 패턴 : interface, 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것.
- abstract 상속으로 관심사를 분리할 경우 다중 상속, 여전한 관심사 분리 실패로 문제가 생길 수 있다.
- 그래서 abstract에 비해 의존성이 더 느슨한 interface를 사용한다. 
- 하지만 어떤 오브젝트를 선택할지 결정하는 것에 있어, 해당 클래스와 직접적으로 연결되기 때문에 아직 관심사가 분리 되지 못했다.
- 그 해답은, 클라이언트 오브젝트를 이용하는 것이다.
  - 클라이언트 오브젝트에 서비스 클래스 및 인터페이스 클래스를 선언 후 의존관계를 설정한다.

## 키워드

- DAO, DTO, VO
- 자바 빈
- 리펙토링
- 디자인 패턴 / 템플릿 메소드 패턴 / 팩토리 메소드 패턴
- 

## 생각 정리

- Interface는 abstract보다 의존성을 더 느슨하게 할 수 있다.
- 디자인 패턴 정의 및 종류 두 가지를 알았다.
- 어떻게 하면 관심사를 분리해 코드 중복을 최소화 할지 알았다.